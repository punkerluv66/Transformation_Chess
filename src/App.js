import React, { useState, useEffect } from 'react';
import ChessBoard from './components/ChessBoard';
import GameInfo from './components/GameInfo';
import GameLobby from './components/GameLobby';
import './App.css';

function App() {
  const [gameMode, setGameMode] = useState('menu');
  const [game, setGame] = useState(null);
  const [gameState, setGameState] = useState(null);
  const [gameKey, setGameKey] = useState(0);
  const [socket, setSocket] = useState(null);
  const [onlineGameData, setOnlineGameData] = useState(null);
  
  const saveRoomData = (roomData, socketId) => {
    if (!roomData || !socketId) {
      console.error('‚ùå Cannot save room data: invalid data or socketId');
      return;
    }
    
    localStorage.setItem('chess_room', JSON.stringify({
      roomId: roomData.roomId,
      playerName: roomData.players.find(p => p.id === socketId)?.name,
      playerColor: roomData.players.find(p => p.id === socketId)?.color,
      timestamp: new Date().getTime()
    }));
    console.log('üîÑ Room data saved to localStorage');
  };

  

  const loadRoomData = () => {
    const savedData = localStorage.getItem('chess_room');
    console.log('üîé Checking for saved room data...', savedData ? 'Found' : 'Not found');
    
    if (savedData) {
      try {
        const parsedData = JSON.parse(savedData);
        console.log('üìä Parsed room data:', parsedData);
        
        if (new Date().getTime() - parsedData.timestamp < 24 * 60 * 60 * 1000) {
          console.log('üîÑ Found valid saved room:', parsedData);
          return parsedData;
        } else {
          console.log('‚è∞ Room data expired, clearing');
          localStorage.removeItem('chess_room');
        }
      } catch (e) {
        console.error('‚ùå Error parsing saved room data:', e);
        localStorage.removeItem('chess_room');
      }
    }
    return null;
  };

  const clearRoomData = () => {
    localStorage.removeItem('chess_room');
    console.log('üßπ Room data cleared from localStorage');
  };
  useEffect(() => {
  const savedRoom = loadRoomData();
  if (savedRoom && savedRoom.roomId) {
    console.log('üîÑ Found saved room, redirecting to lobby');
    setGameMode('lobby');
  }
}, []);
  useEffect(() => {
    if (gameMode === 'local') {
      initLocalGame();
    }
  }, [gameMode]);

  const initLocalGame = () => {
    const initGame = () => {
      if (window.ChessGame) {
        const newGame = new window.ChessGame();
        setGame(newGame);
        setGameState(newGame.getGameState());
      } else {
        setTimeout(initGame, 100);
      }
    };
    initGame();
  };

  const handleOnlineGameStart = (gameSocket, gameData) => {
    console.log('üéÆ Online game starting with existing socket:', {
      socketId: gameSocket.id,
      players: gameData.players,
      myPlayer: gameData.players?.find(p => p.id === gameSocket.id)
    });

    setSocket(gameSocket);
    setOnlineGameData(gameData);
    setGameMode('online');
    saveRoomData(gameData, gameSocket.id);
    
    const initGame = () => {
      if (window.ChessGame) {
        const newGame = new window.ChessGame();
        
        if (gameData.gameState) {
          newGame.board = gameData.gameState.board;
          newGame.currentPlayer = gameData.gameState.currentPlayer;
          newGame.gameStatus = gameData.gameState.gameStatus;
        }
        
        setGame(newGame);
        setGameState(newGame.getGameState());
        
        setupGameEvents(gameSocket, newGame);
      } else {
        setTimeout(initGame, 100);
      }
    };
    
    initGame();
  };

  const setupGameEvents = (gameSocket, gameInstance) => {
    gameSocket.off('gameStateUpdate');
    gameSocket.off('gameReset');
    gameSocket.off('moveError');
    gameSocket.off('playerReconnected');

    gameSocket.on('gameStateUpdate', (data) => {
      console.log('üì° Game state update received:', data);
      
      gameInstance.board = data.gameState.board;
      gameInstance.currentPlayer = data.gameState.currentPlayer;
      gameInstance.gameStatus = data.gameState.gameStatus;
      gameInstance.selectedSquare = null;
      gameInstance.possibleMoves = [];
      
      setGameState({...data.gameState});
      setGameKey(prev => prev + 1);
    });

    gameSocket.on('gameReset', (newGameState) => {
      console.log('üîÑ Game reset received');
      gameInstance.resetGame();
      setGameState(gameInstance.getGameState());
      setGameKey(prev => prev + 1);
    });
    
    gameSocket.on('moveError', (error) => {
      console.error('‚ùå Move error:', error);
      alert(`Move error: ${error}`);
    });
    gameSocket.on('playerReconnected', (data) => {
    console.log(`üëã Player ${data.name} reconnected as ${data.color}`);
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –∏–≥—Ä–æ–∫–æ–≤ —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ —Ü–≤–µ—Ç–∞–º–∏
    if (onlineGameData) {
      const updatedPlayers = [...onlineGameData.players];
      const playerIndex = updatedPlayers.findIndex(p => p.name === data.name);
      if (playerIndex !== -1) {
        updatedPlayers[playerIndex].id = gameSocket.id; // –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ gameSocket, –∞ –Ω–µ socket
        setOnlineGameData({
          ...onlineGameData,
          players: updatedPlayers
        });
      }
    }
  });
  gameSocket.on('opponentLeft', (data) => {
    console.log('üëã Opponent left the game:', data);
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã - –ø–æ–±–µ–¥–∞!
    gameInstance.gameStatus = 'checkmate';
    gameInstance.isGameOver = true;
    gameInstance.winner = data.winnerColor;
    
    // –û–±–Ω–æ–≤–ª—è–µ–º UI
    setGameState({
      ...gameInstance.getGameState(),
      gameStatus: 'checkmate',
      isGameOver: true,
      winner: data.winnerColor,
      message: `${data.opponentName} left the game. You win!`
    });
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    alert(`${data.opponentName} left the game. You win!`);
    
    // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º –Ω–∞ —Ä–µ–∂–∏–º –æ–∂–∏–¥–∞–Ω–∏—è –Ω–æ–≤–æ–≥–æ –æ–ø–ø–æ–Ω–µ–Ω—Ç–∞
    setTimeout(() => {
      setGameMode('lobby');
    }, 3000);
  });
};


  const handleSquareClick = (row, col) => {
    console.log(`üéØ App handleSquareClick called: ${row}, ${col}`, { 
      gameMode, 
      hasGame: !!game, 
      hasSocket: !!socket,
      socketId: socket?.id,
      socketConnected: socket?.connected,
      hasOnlineGameData: !!onlineGameData
    });
    
    if (gameMode === 'local') {
      // –õ–æ–∫–∞–ª—å–Ω–∞—è –∏–≥—Ä–∞
      if (!game || gameState?.isGameOver) {
        console.log('‚ùå Local game blocked:', { hasGame: !!game, isGameOver: gameState?.isGameOver });
        return;
      }
      
      console.log('‚úÖ Making local move');
      const result = game.selectSquare(row, col);
      setGameState(result.gameState);
      if (result.moved) {
        setGameKey(prev => prev + 1);
      }
      
    } else if (gameMode === 'online') {
      // –û–Ω–ª–∞–π–Ω –∏–≥—Ä–∞
      if (!socket || !socket.id || !socket.connected) {
        console.log('‚ùå Socket not connected:', {
          hasSocket: !!socket,
          socketId: socket?.id,
          connected: socket?.connected
        });
        alert('Connection lost! Please refresh and try again.');
        return;
      }
      
      if (!game || !onlineGameData || gameState?.isGameOver) {
        console.log('‚ùå Cannot make move - missing dependencies');
        return;
      }
      
      console.log('üîç Online game debugging:', {
        socketId: socket.id,
        players: onlineGameData.players,
        playersDetails: onlineGameData.players?.map(p => ({
          id: p.id,
          name: p.name,
          color: p.color,
          isCurrentSocket: p.id === socket.id
        }))
      });
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ —Ö–æ–¥ —Ç–µ–∫—É—â–µ–≥–æ –∏–≥—Ä–æ–∫–∞
      const currentPlayerData = onlineGameData.players.find(p => p.id === socket.id);
      if (!currentPlayerData) {
        console.log('‚ùå Player not found in game data:', {
          socketId: socket.id,
          availablePlayers: onlineGameData.players?.map(p => p.id)
        });
        return;
      }
      
      console.log(`üéÆ Current turn check:`, {
        playerColor: currentPlayerData.color,
        currentTurn: gameState.currentPlayer,
        match: currentPlayerData.color === gameState.currentPlayer
      });
      
      if (currentPlayerData.color !== gameState.currentPlayer) {
        console.log(`‚ùå Not your turn! You are ${currentPlayerData.color}, current turn: ${gameState.currentPlayer}`);
        return;
      }
      
      // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–¥ —Ö–æ–¥–æ–º
      const selectedSquare = game.selectedSquare;
      
      console.log(`üéØ Making online move:`, {
        selectedSquare,
        target: { row, col },
        boardPiece: gameState.board[row][col]
      });
      
      // –ü—Ä–∏–º–µ–Ω—è–µ–º –ª–æ–≥–∏–∫—É —Ö–æ–¥–∞ –ª–æ–∫–∞–ª—å–Ω–æ –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏
      const result = game.selectSquare(row, col);
      
      console.log(`üé≤ Move result:`, {
        moved: result.moved,
        newCurrentPlayer: result.gameState.currentPlayer,
        selectedSquare: result.gameState.selectedSquare,
        possibleMoves: result.gameState.possibleMoves?.length || 0
      });
      
      // –ï—Å–ª–∏ —Ö–æ–¥ –±—ã–ª –≤—ã–ø–æ–ª–Ω–µ–Ω (—Ñ–∏–≥—É—Ä–∞ –ø–µ—Ä–µ–º–µ—Å—Ç–∏–ª–∞—Å—å)
      if (result.moved) {
        console.log('‚úÖ Move made locally, sending to server');
        
        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ö–æ–¥ –Ω–∞ —Å–µ—Ä–≤–µ—Ä
        socket.emit('makeMove', {
          roomId: onlineGameData.roomId,
          from: selectedSquare,
          to: { row, col },
          gameState: result.gameState
        });
        
        // –ù–ï –æ–±–Ω–æ–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ - –¥–æ–∂–¥–µ–º—Å—è –æ—Ç–≤–µ—Ç–∞ —Å–µ—Ä–≤–µ—Ä–∞
      } else {
        // –ü—Ä–æ—Å—Ç–æ –æ–±–Ω–æ–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ (–≤—ã–¥–µ–ª–µ–Ω–∏–µ —Ñ–∏–≥—É—Ä—ã)
        console.log('üéØ Piece selected or deselected, updating local state');
        setGameState(result.gameState);
      }
    }
  };

  const handleResetGame = () => {
    if (gameMode === 'local') {
      if (!game) return;
      game.resetGame();
      setGameState(game.getGameState());
      setGameKey(prev => prev + 1);
    } else if (gameMode === 'online' && socket && onlineGameData) {
      socket.emit('resetGame', onlineGameData.roomId);
    }
  };

  const backToMenu = () => {
  if (socket && socket.connected && onlineGameData) {
    socket.emit('leaveGame', {
      roomId: onlineGameData.roomId,
      playerColor: onlineGameData.players.find(p => p.id === socket.id)?.color
    });
    
    clearRoomData();
  }
  
  setGameMode('menu');
  setGame(null);
  setGameState(null);
  setSocket(null);
  setOnlineGameData(null);
};

  const getPlayerColor = () => {
    if (gameMode === 'online' && onlineGameData && socket) {
      const playerData = onlineGameData.players.find(p => p.id === socket.id);
      return playerData ? playerData.color : null;
    }
    return null;
  };

  const getOpponentName = () => {
    if (gameMode === 'online' && onlineGameData && socket) {
      const opponent = onlineGameData.players.find(p => p.id !== socket.id);
      return opponent ? opponent.name : 'Unknown';
    }
    return null;
  };

  if (gameMode === 'menu') {
    return (
      <div className="app">
        <h1>üè∞ Transformation Chess</h1>
        <div className="menu-container">
          <div className="menu-options">
            <button 
              className="menu-button local-game"
              onClick={() => setGameMode('local')}
            >
              üéÆ Play Local Game
            </button>
            <button 
              className="menu-button online-game"
              onClick={() => setGameMode('lobby')}
            >
              üåê Play Online
            </button>
          </div>
          <div className="game-description">
            <h3>How to Play:</h3>
            <ul>
              <li>Standard chess rules apply</li>
              <li>Pieces can fuse with ally pieces (except King)</li>
              <li>Fused pieces combine movement abilities</li>
              <li>Win by checkmate or capturing the enemy King</li>
            </ul>
          </div>
        </div>
      </div>
    );
  }

  if (gameMode === 'lobby') {
    const savedRoomData = loadRoomData();
  return <GameLobby onGameStart={handleOnlineGameStart} savedRoomData={savedRoomData} />;
  }

  if (!game || !gameState) {
    return (
      <div className="app">
        <h1>Transformation Chess</h1>
        <div>Loading game...</div>
        <div>Game: {game ? '‚úÖ' : '‚ùå'}</div>
        <div>State: {gameState ? '‚úÖ' : '‚ùå'}</div>
        <div>Mode: {gameMode}</div>
      </div>
    );
  }

  return (
    <div className="app">
      <div className="game-header">
        <h1>
          Transformation Chess {gameMode === 'online' ? 'üåê' : 'üè†'}
          {gameMode === 'online' && getPlayerColor() && (
            <span className={`player-color ${getPlayerColor()}`}>
              {` - You are ${getPlayerColor().toUpperCase()}`}
            </span>
          )}
        </h1>
        <button className="back-button" onClick={backToMenu}>
          ‚Üê Back to Menu
        </button>
      </div>
      
      {gameMode === 'online' && (
        <div className="online-game-info">
          {getOpponentName() && (
            <div className="opponent-info">
              <p>Playing against: <strong>{getOpponentName()}</strong></p>
            </div>
          )}
          <div className="turn-info">
            <p>Current turn: <strong>{gameState.currentPlayer?.toUpperCase()}</strong></p>
            {gameState.currentPlayer === getPlayerColor() ? (
              <p className="your-turn">üü¢ Your turn!</p>
            ) : (
              <p className="their-turn">üî¥ Opponent's turn</p>
            )}
          </div>
        </div>
      )}
      
      {gameState.isGameOver && (
        <div className="victory-banner">
          üéâ GAME OVER! üéâ
        </div>
      )}
      
      <div className="game-container">
        <ChessBoard
          key={gameKey}
          gameState={gameState}
          onSquareClick={handleSquareClick}
          game={game}
          playerColor={getPlayerColor()}
        />
        <GameInfo
          gameState={gameState}
          onResetGame={handleResetGame}
          gameMode={gameMode}
          onlineGameData={onlineGameData}
          playerColor={getPlayerColor()}
          opponentName={getOpponentName()}
        />
      </div>
    </div>
  );
}

export default App;